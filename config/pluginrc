" {{{ NeoBundle
" {{{ g:neobundle#install_max_processes
" The max number of processes used for neobundle/install source asynchronous
" update.
let g:neobundle#install_max_processes = 1
"}}}

let g:bundlePath=split(&runtimepath, ',')[0] . '/bundle'
let g:pathToNeoBundle=expand(bundlePath).'/NeoBundle'
if filereadable(pathToNeoBundle.'/plugin/neobundle.vim')
    " {{{ initialize
    if has('vim_starting')
        set nocompatible
        let &runtimepath.=','.expand(pathToNeoBundle)
    endif
    "}}}

    " {{{ bundle path and call NeoBundle
    call neobundle#begin(expand(bundlePath))
    "}}}

    " {{{ Bundles
    " {{{ NeoBundle
    NeoBundleFetch 'Shougo/neobundle.vim', {
                \ 'depends': [
                \    ['Shougo/vimproc.vim', {
                \        'directory': 'Proc',
                \        'name': 'Proc',
                \        'build': {
                \            'windows': 'vimproc_updcmd',
                \            'cygwin': 'make -f make_cygwin.mak',
                \            'mac': 'make -f make_mac.mak',
                \            'unix': 'make -f make_unix.mak',
                \        },
                \    }],
                \ ],
                \ 'directory': 'NeoBundle',
                \ 'name': 'NeoBundle',
                \ }
    "}}}

    " {{{ Plugins
    NeoBundle 'bling/vim-airline', {
                \ 'directory': 'Airline',
                \ 'disabled': has('mac'),
                \ 'name': 'Airline'
                \ }

    NeoBundle 'chrisbra/csv.vim', {
                \ 'directory': 'CSV',
                \ 'name': 'CSV'
                \ }

    NeoBundle 'rodjek/vim-puppet', {
                \ 'directory': 'Puppet',
                \ 'name': 'Puppet'
                \ }

    NeoBundle 'godlygeek/tabular', {
                \ 'directory': 'Tabular',
                \ 'name': 'Tabular'
                \ }

    NeoBundle 'Shougo/unite.vim', {
                \ 'depends': [
                \    ['Shougo/tabpagebuffer.vim', {
                \        'directory': 'TabpageBuffer',
                \        'name': 'TabpageBuffer'
                \        }]
                \    ],
                \ 'directory': 'Unite',
                \ 'name': 'Unite'
                \ }

    NeoBundle 'ntpeters/vim-better-whitespace', {
                \ 'directory': 'Whitespace',
                \ 'name': 'Whitespace'
                \ }
    "}}}

    call neobundle#end()
    "}}}
endif
unlet pathToNeoBundle
unlet bundlePath
"}}}

" {{{ Bufexplorer disabled
let g:bufexplorer_version = 1
"}}}

" {{{ MiniBufExpl disabled
let g:loaded_minibufexplorer = 1
"}}}

" {{{ Airline
" {{{ tabline
" enable/disable enhanced tabline.
let g:airline#extensions#tabline#enabled = 1

" enable/disable displaying buffers with a single tab.
let g:airline#extensions#tabline#show_buffers = 1

" configure how numbers are calculated in tab mode.
let g:airline#extensions#tabline#tab_nr_type = 1

" enable/disable displaying tab number in tabs mode.
let g:airline#extensions#tabline#show_tab_nr = 1
"}}}
"}}}

" {{{ LaTeX
" {{{ tex_flavor
" If the first line of a *.tex file has the form
"	%&<format>
" then this determined the file type: plaintex (for plain TeX), context (for
" ConTeXt), or tex (for LaTeX). Otherwise, the file is searched for keywords
" to choose context or tex. If no keywords are found, it defaults to plaintex.
" You can change the default by defining the variable g:tex_flavor to the
" format (not the file type) you use most. Use one of these:
"	let g:tex_flavor = "plain"
"	let g:tex_flavor = "context"
"	let g:tex_flavor = "latex"
" Currently no other formats are recognized.
let g:tex_flavor = 'latex'
"}}}
"}}}

"{{{ LaTeX-Suite
" {{{ Tex_DefaultTargetFormat
" Use this setting to choose the default target format. For example, setting
" this to pdf makes LaTeX-Suite compile a pdf file when you press \ll and fire
" up the pdf viewer on pressing \lv. Make sure that a rules for compiling and
" viewing have been defined for this target format as described here [ls_a_dx]
" and here [ls_a_dF].
let g:Tex_DefaultTargetFormat = 'pdf'
"}}}
"}}}

" {{{ Syntastic
" {{{ syntastic_check_on_open
" If enabled, syntastic will do syntax checks when buffers are first loaded as
" well as on saving
if ! &diff
    let g:syntastic_check_on_open = 1
endif
"}}}

" {{{ syntastic_check_on_wq
" Normally syntastic runs syntax checks whenever buffers are written to disk. If
" you want to skip these checks when you issue |:wq|, |:x|, and |:ZZ|, set this
" variable to 0.
if ! &diff
    let g:syntastic_check_on_wq = 0
endif
"}}}

" {{{ syntastic_aggregate_errors
" When enabled, syntastic runs all checkers that apply to the current filetype,
" then aggregates errors found by all checkers and displays them. When disabled,
" syntastic runs each checker in turn, and stops to display the results the
" first time a checker finds any errors.
let g:syntastic_aggregate_errors = 1
"}}}

" {{{ syntastic_auto_loc_list
" Use this option to tell syntastic to automatically open and/or close the
" location-list (see syntastic-error-window).
" When set to 0 the error window will not be opened or closed automatically. >
"     let g:syntastic_auto_loc_list = 0
" When set to 1 the error window will be automatically opened when errors are
" detected, and closed when none are detected.
"     let g:syntastic_auto_loc_list = 1
" When set to 2 the error window will be automatically closed when no errors are
" detected, but not opened automatically.
"     let g:syntastic_auto_loc_list = 2
let g:syntastic_auto_loc_list = 1
"}}}

" {{{ syntastic_filetype_map
" Use this option to map non-standard filetypes to standard ones. Corresponding
" checkers are mapped accordingly, which allows syntastic to check files with
" non-standard filetypes
let g:syntastic_filetype_map = {
            \ 'latex': 'tex',
            \ }
"}}}

" {{{ syntastic_mode_map
" Use this option to fine tune when automatic syntax checking is done (or not
" done).
let g:syntastic_mode_map = {
            \ 'mode': 'active',
            \ 'active_filetypes': [
            \    'php',
            \    'python',
            \    'ruby'
            \ ],
            \ 'passive_filetypes': [
            \    'html',
            \    'puppet'
            \ ]}
"}}}

" {{{ mappings
nmap <silent> <leader>Sc :SyntasticCheck<cr>
nmap <silent> <leader>Se :Errors<cr>
nmap <silent> <leader>Si :SyntasticInfo<cr>
nmap <silent> <leader>Sr :SyntasticReset<cr>
nmap <silent> <leader>St :SyntasticToggleMode<cr>
"}}}

" {{{ Syntax Checker
" {{{ HTML
let g:syntastic_html_checkers = [
            \ 'tidy',
            \ 'jshint'
            \ ]
"}}}

" {{{ PHP
" {{{ syntastic_<filetype>_<checker>_exec
if executable('./bin/phpcs')
    let g:syntastic_php_phpcs_exec = './bin/phpcs'
endif
if executable('./bin/phpmd')
    let g:syntastic_php_phpmd_exec = './bin/phpmd'
endif
"}}}

" {{{ syntastic_php_phpcs_args
let g:syntastic_php_phpcs_args = "--standard=zend -l --extensions=php --tab-width=" . &tabstop
"}}}

let g:syntastic_php_checkers = [
            \ 'php',
            \ 'phplint',
            \ 'phpmd',
            \ 'phpcs'
            \ ]
"}}}

" {{{ Puppet
" puppet check
let g:syntastic_puppet_checkers = [
            \ 'puppet',
            \ 'puppetlint'
            \ ]

"}}}

" {{{ Python
" python check
let g:syntastic_python_checkers = [
            \ 'python',
            \ 'flake8',
            \ 'pep8',
            \ 'pyflakes',
            \ 'pylint'
            \ ]
"}}}

" {{{ Ruby
" ruby checker
let g:syntastic_ruby_checkers = [
            \ 'mri',
            \ 'rubylint'
            \ ]
"}}}

" {{{ VIm
" vim check
let g:syntastic_vim_checkers = [
            \ 'vim',
            \ 'vimlint'
            \ ]
"}}}

" {{{ XML
" xml check
let g:syntastic_xml_checkers = [
            \ 'xmllint',
            \ 'plutil'
            \ ]
"}}}
"}}}
"}}}

" {{{ Unite
" {{{ unite_data_directory
" Specify directories to store unite configurations. Used by both unite itself
" and its sources. If the directory doesn't exist, the directory is
" automatically created. For example source of file_mru saves the information of
" the most recent used files into this directory.
let g:unite_data_directory = g:vimfiles . '/tmp/unit/'
"}}}

" {{{ unite_source_buffer_time_format
" Specify the output format of the last access time of unite-source-buffer. Uses
" strftime() formatting.
let g:unite_source_buffer_time_format = '%Y-%m-%d %H:%M'
"}}}

" {{{ unite_source_grep_max_candidates
" Set the max number of |unite-source-grep| candidates.
let g:unite_source_grep_max_candidates = 250
"}}}

" {{{ unite_source_history_yank_enable
" If defined and not 0, unite enables unite-source-history/yank.
let g:unite_source_history_yank_enable = 1
"}}}

" {{{ unite_source_history_yank_file
" Specify the file to write the information of yank history. If this variable is
" empty, saving history is disabled.
let g:unite_source_history_yank_file = g:vimfiles . '/tmp/yank'
"}}}

" {{{ unite#custom#profile()
call unite#custom#profile(
            \ 'default', 'context', {
            \    'prompt': 'unite: ',
            \    'winheight': 15
            \ })
"}}}

" {{{ mappings
nmap <silent> <leader>u :Unite -buffer-name=unite<cr>
nmap <silent> <leader>ub :Unite -buffer-name=buffer -quick-match buffer_tab<cr>
nmap <silent> <leader>ug :Unite -buffer-name=grep -start-insert grep:.<cr>
nmap <silent> <leader>uj :Unite -buffer-name=tabs jump<cr>
nmap <silent> <leader>um :Unite -buffer-name=menu -start-insert menu<cr>
nmap <silent> <leader>umd :Unite -buffer-name=mru -quick-match neomru/directory<cr>
nmap <silent> <leader>umf :Unite -buffer-name=mru -quick-match neomru/file<cr>
nmap <silent> <leader>uo :Unite -buffer-name=outline -quick-match outline<cr>
nmap <silent> <leader>ur :Unite -buffer-name=register register<cr>
nmap <silent> <leader>us :Unite -buffer-name=session session<cr>
nmap <silent> <leader>ut :Unite -buffer-name=tabs -start-insert tab<cr>
nmap <silent> <leader>uTf :Unite -buffer-name=tag-file -quick-match tag/file<cr>
nmap <silent> <leader>uTi :Unite -buffer-name=tag-include -quick-match tag/include<cr>
nmap <silent> <leader>uTt :Unite -buffer-name=tag -quick-match tag<cr>
nmap <silent> <leader>uy :Unite -buffer-name=history history/yank<cr>

nmap <silent> <C-p> :Unite -buffer-name=files -start-insert file_rec/git<cr>
"}}}
"}}}

" vim: filetype=vim textwidth=80 foldmethod=marker
